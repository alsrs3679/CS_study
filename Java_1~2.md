## Java

#### Java의 Collection

자바의 대표 Collection에는 List, Map, Set, Stack, Queue와 같은 것들이 있다. 이 추상화된 Collection 인터페이스 아래, 특정한 기법으로 구현된 자료구조가 들어간다. 예를 들어, List라는 인터페이스에는 구현방법에 따라 ArrayList가 들어갈 수도, LinkedList가 들어갈 수도 있다.

- List
  - ArrayList
    자바의 Vector를 개선한, 배열로 구현된 List이다. 그 말인 즉슨, 데이터가 저장된 순서가 같다는 말이다. 사실상 배열과 같은 자료구조이기 때문에, 리스트의 연산 자체의 수행시간 속도는 배열과 같다.
  - LinkedList
    다음 노드의 주소를 기억하고 있는 List로, 배열에 비해 삽입과 삭제가 간단하다. 그러나 탐색의 경우 첫 번째 노드부터 탐색해 나가야 하기 때문에 느리다.
- Map
  - HashMap
    가장 일반적으로 사용하는 Map. HashTable을 사용, Key값에 해시함수를 적용하여 나온 index에 Value를 저장하는 식. 중복성을 허용하지 않으며, 순서가 없다는 것이 특징
  - TreeMap
    Red-Black Tree 자료구조를 이용한 Map이다. Tree 구조이기 때문에 어느 정도 순서를 보장한다.
  - LinkedHashMap
    LinkedList로 구현된 HashMap이다. List로 구현되어있기 때문에 순서가 보장된다. 하지만 LinkedList 특성상 랜덤 접근에서 느릴 수 있다.
- Set
  - HashSet
    HashMap에서 Key값이 없는 자료형. 집합이라고 생각해도 무방하다. 값이 포함되어 있는지 아닌지만 관심이 있다. 순서를 보장하지 않으며, 중복값을 허용하지 않는다. Set중에는 가장 많이 사용된다.
  - TreeSet
    Red-Black Tree 자료구조를 사용한 Set.
  - LinkedHashSet
    LinkedList로 구현된 HashSet. 순서를 보장한다.
- Stack & Queue
  - Stack
    직접 new 연산자로 객체를 생성하여 사용 가능.
  - Queue
    LinkedList 에 new 연산자로 객체를 생성함으로서 사용 가능.

추가로 자바 Array와 ArrayList의 다른점.
둘 다 배열이라는 점은 동일하나, Array는 인덱스로 접근하는 반면, ArrayList는 메서드를 통해 접근한다(어짜피 Index로 호출한다는 점은 동일 하겠지만..). 또한 Array는 Object 뿐만 아니라 원시 형태(Primitive, 예를 들어 int, double 등)도 담을 수 있지만, Array는 Object형(Reference, 객체)만 담을 수 있다. 따라서 정수를 ArrayList에 넣을 경우 Integer형은 가능하지만 int형은 안 된다. 덧붙여서, Integer처럼 int와 같은 원시타입을 담을 수 있는 객체를 Wrapper Class라고 한다.

#### OOP, AOP, FP

각각의 프로그래밍 기법에 대해 설명할 수 있어야 한다. 특히 OOP는 단골 질문이라 하니 중요.

- OOP (객체지향 프로그래밍) **(중요)**
  객체지향 프로그래밍은 컴퓨터 프로그래밍 패러다임(견해, 사고법)의 하나로, **프로그래밍에서 필요한 데이터를 추상화 시켜서 상태(속성, 어트리뷰트)와 행위(메서드)를 가진 객체** 로 만들고, 그 객체간의 상호작용을 통해 로직을 구성하는 방법.
  - 장점
    - 다른 클래스를 가져와 사용할 수 있고, 상속받을 수 있어 코드의 재사용성 증가
    - 절차지향보다 유지보수가 간단
    - 클래스 단위로 모듈화가 가능하여, 대형 프로젝트에 적합
  - 단점
    - 처리속도가 상대적으로 느리다.
    - 객체가 많으면 용량이 커진다.
    - 설계시 많은 노력과 시간이 필요하다.
  - OOP의 6가지 키워드
    - 클래스
      현실 세계의 객체를 추상화시켜, 속성과 메서드로 정의한 것 (논리적 개념)
    - 인스턴스
      클래스에서 정의한 것을 토대로 만든 실제 메모리상에 할당된 것, 실제 데이터
    - 추상화
      객체지향 관점에서 클래스를 정의하는 것, 불필요한 정보 외 중요한 정보만 표현함으로써 공통의 속성과 기능을 묶어 이름을 붙이는 것.
    - 캡슐화
      코드를 수정없이 재활용 하는 것을 목적으로 함. 클래스라는 캡슐에 기능과 특성을 담아 묶는다. 목적을 기준으로 묶는다.
      은닉화와의 차이 - 은닉화는 캡슐화의 일부라고 볼 수 있으며, 목적으로 묶인 캡슐 안을 사용자는 볼 수 없다는 것이 은닉화.
    - 상속
      클래스로부터 속성과 메서드를 물려받는 것을 말함. 다른 클래스를 가져와서 수정할 일이 있다면, 그 클래스를 직접 수정하는 대신 상속을 받아 변경하고자 하는 부분만 변경
    - 다형성
      하나의 변수명이나 함수명이 상황에 따라 다르게 해석될 수 있음. 대표적인 다형성이 오버라이딩과 오버로딩
  - OOP의 5가지 법칙 (SOLID)
    - Single Responsibility Principle, 단일 책임 법칙
      각 클래스는 목적을 하나씩만 가지고 그에 대한 책임을 져야 한다.
    - Open Close Principle, 개방 폐쇄 법칙
      각 클래스는 클래스에 대한 수정을 폐쇄하고, 확장에 대해 개방해야 한다.
      즉 클래스를 수정해야 한다면 그 클래스를 상속, 즉 확장하여 수정한다.
    - Liskov Substitusion Principle, 리스코프 치환 법칙
      자식 클래스를 사용 중일때, 거기에 부모 클래스로 치환하여도 문제가 없어야 한다.
    - Interface Segreation Principle, 인터페이스 분리 법칙
      각 행위에 대한 인터페이스는 서로 분리되어야 한다.
      핸드폰을 예로 들면, 전화를 하는데 핸드폰 카메라가 방해가 되면 안된다는 말.
    - Dependency Inversion Principle, 의존성 역전 법칙
      상위 클래스가 하위 클래스에 의존하면 안된다는 법칙. 즉 기본적인 공통되는 속성을 하위 클래스에 의존하면 안된다.
- AOP (관점지향 프로그래밍)
  스프링 프레임워크의 핵심 요소 중 하나. 비즈니스 로직과 공통 모듈로 분리하고, 핵심 로직 사이사이에 공통 모듈을 잘 끼워 넣는 것을 말함. 이때 공통 모듈을 코드 밖에서 설정된다는 것이 핵심. 인증, 로깅, 트랜잭션 처리에 용이.
- FP (함수형 프로그래밍)
  함수형 프로그래밍은 선언형 프로그래밍으로, 어떻게(How)가 아닌 무엇(What)을 정의한다. C, Java등의 언어는 명령형 프로그래밍이며, 알고리즘을 기술하고 목적은 기술하지 않는다. 선언형은 반대로 알고리즘은 기술하지 않고 목적 위주로 기술하며, 데이터의 입력이 주어지고 데이터의 흐름을 추상적을 정의하는 방식.