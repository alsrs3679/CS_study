## 운영체제

#### 프로세스와 스레드

**프로세스** 는 실행 중인 프로그램이다. 디스크에서 메모리로 적재되어, CPU 자원의 할당을 받을 수 있는 것을 말한다. 프로세스 에 할당되는 메모리 안에는 스택, 힙, 데이터, 코드 영역을 포함한다.

**PCB** 란 Process Control Block의 약자로, 프로세스 제어 블록이다. 프로세스에 대한 중요한 정보를 저장하고 있다. 운영체제가 프로세스를 표현한 것이라고도 한다. 프로세스 생성시 만들어지며, 주기억장치에 유지된다. 문맥전환 등 다른 프로세스를 처리해야 할 때, PCB에 현재 상태를 저장함으로써 나중에 그 작업 상태를 불러와 작업 재개가 가능해진다. PID, 상태, 다음 명령어 주소 등의 정보가 저장됨.

**PC** 란 Program Counter의 줄임말로, 다음에 실행될 명령어의 주소가 들어있는 레지스터이다. 명령어가 인출되면, 자동으로 다음 명령어를 가리키도록 주소값이 증가된다.

**캐시메모리** 란 CPU의 레지스터와 메모리 사이에서, 캐싱을 통해 병목 현상을 완화하는 것을 말한다.

**스레드** 는 프로세스의 작업 실행 단위이다. 즉 멀티스레드라는 것은 한 프로세스 내에 여러개의 프로그램의 흐름을 말한다. 스레드간에는 프로세스의 주소나 자원을 공유할 수 있다. 스레드는 스레드 ID, PC, 레지스터 집합, 스택으로 구성된다. 스레드 간에는 각자 독립적으로 작업을 수행해야 하기 때문에, 각각 스택과 PC 레지스터를 받는다.

#### 멀티 스레드 환경

하나의 프로세스에서 다수의 실행 단위로 구분하여 자원의 생성과 관리의 중복성을 최소화하여 효율을 높이는 것을 멀티 스레딩이라고 한다.

장점 :

- 멀티 프로세스에 비해 메모리와 자원의 소모가 줄어든다.
- 힙 영역을 사용하면 프로세스간 통신에 비해 스레드간 통신이 훨씬 간단하다.
- 스레드의 문맥전환은 캐시메모리를 비울 필요가 없어 프로세스의 문맥전환에 비해 더 빠르다.
- 그러므로, 시스템의 처리량이 늘며, 공간과 시간, 자원이 절약된다.

단점 :

- 힙 영역을 공유하기 때문에, 해당 자원을 사용할 때 동기화를 해주어야 함.
- 동기화를 위해 과도한 락 사용시 병목 현상때문에 성능이 저하될 수 있음

멀티 스레드 VS 멀티 프로세스
이 두 가지는 실행 단위를 구분한다는 점은 같지만, 멀티 스레드는 자원을 덜 소모하는 대신 하나의 스레드가 비정상적인 오류를 일으키면 다른 스레드도 종료될 수가 있다는 점과 동기화 문제를 안고 있다. 멀티 프로세스는 자원을 공유하지 않기에 서로간 통신이 멀티 스레드보다 불편하고, CPU 자원을 더 많이 소모한다. 결국 상황에 맞게 골라서 써야한다.

#### 멀티 프로세싱과 멀티 프로그래밍 멀티 태스킹

CPU 코어의 관점에서 생각
CPU 코어 여러개로 프로세스를 여러개 수행한다 -> 멀티 프로세싱
CPU 코어 하나로 프로세스를 여러개 수행한다 -> 멀티 프로그래밍
CPU 코어 몇 개를 쓰던 간에 작업을 수행한다 (프로세스보다 확장된 의미) -> 멀티 태스킹

#### 프로세스(스레드)의 동기화

경쟁 상태 (Race Condition) :
경쟁 상태란 두 개 이상의 프로세스 혹은 스레드가 공유 자원을 동시에 사용할 때 그 순서에 따라 결과가 달라지는 문제.
은행 잔고를 예제로 들면 은행 잔고라는 공유 데이터를 읽어와서 입금 연산과 출금 연산을 하는데, 동시에 접근해서 연산해버리면 한 쪽 연산이 반영이 안되는 문제

임계영역과 크리티컬 섹션 :
사전상으로는 같은 말이지만, 의미하는 바가 다를 수 있다.
임계영역은 프로세스간 자원이 공유될 수 있는 코드 블록을 의미하며, 크리티컬 섹션은 하나의 동기화 방법을 말한다. 임계 영역을 프로세스들이 같이 쓸 수 있는 전제 조건은 다음과 같다.

- 상호 배제 (Mutal Exculsion) : 프로세스가 크리티컬 섹션에 들어가 있다면, 다른 프로세스는 크리티컬 섹션에 들어갈 수 없다.
- 진행 (Progress) : 크리티컬 섹션에 들어가 있는 프로세스가 없다면 다른 후보 프로세스가 진입할 수 있다.
- 한정된 대기 (Bounded Waiting) : 프로세스가 진입 가능한 횟수에는 제한이 있다(특정한 한 프로세스만 계속 진입하는 것을 방지).

Lock :
하드웨어 기반 처리로, 임계 영역에 진입하기 위해서는 Lock이 필요하다. 임계 영역에 들어가는 프로세스는 Lock을 획득하고, 빠져나올때 Lock을 반납한다. 다중 처리기 환경에서 성능을 보장할 수 없다.

세마포어 :
OS는 카운팅/이진 세마포어를 구분한다.

- 카운팅 세마포어 : 동시에 사용가능한 자원에 대해 사용되며, 임계영역 안에 스레드나 프로세스가 들어오면 카운트를 증가시켜, 일정 숫자만큼의 스레드만 사용하게 하는 것
- 이진 세마포어 : 0과 1로만 된 세마포어로, 임계영역 안에 하나의 프로세스만 들어갈 수 있다. 뮤텍스라고도 함.

단점 :
Busy Waiting : 임계 영역에 진입하려는 프로세스는 계속해서 진입하는 코드를 실행해야 한다. 따라서 성능의 저하가 발생할 수 있음.

세마포어에서도 데드락이 발생할 수 있다.

모니터 :
고급 언어의 개념으로, 추상화 메서드를 통해 동기화함. 세마포어에 비해 간단.

#### 데드락

멀티 프로그래밍 환경에서 CPU와 같은 한정되고 공동된 자원을 사용할 때 데드락이 발생할 수 있다.
예를 들어 프로세스 A가 자원 1을 사용 중인 상태에서 자원 2를 사용하려고 하지만 프로세스 B가 자원 2를 이미 사용하고 있어 대기중이다. 그런데 프로세스 B가 자원 2 사용을 끝내려면 자원 1이 필요한데, 프로세스 A가 이미 자원 1을 사용하고 있기 때문에 대기해야 한다. 즉 서로의 자원을 쓰고 싶은데 서로가 쓰지를 못하니 무한 대기상태가 걸리는데 이를 데드락, 교착상태라 한다.

데드락의 발생 조건 4가지(모두 만족해야 함) :
상호 배제 : 한 자원은 한 프로세스에 의해서만 사용됨, 두 개 이상 사용 불가
점유 대기 : 프로세스는 자원을 가진 채 다른 자원을 기다릴 수 있음
비선점 : 다른 프로세스가 사용 중인 자원을 강제로 가져올 수 없음
순환 대기 : 프로세스의 집합에서, 각 프로세스는 순환적으로 다음 프로세스가 필요로 하는 자원을 가지고있다.

데드락 해결법 :
예방 : 4가지 조건 중 하나라도 만족되지 못하게 함
회피 : 알고리즘을 데드락이 발생하지 않도록 적용
회복 : 교착상태가 발생하면 그때 해결함
무시 : 회복과정의 성능저하가 더 심하다면 그냥 무시함

#### 컨텍스트 스위칭

멀티 프로세스 환경에서 CPU 스케줄러가 인터럽트 발생 시 현재 프로세스의 상태를 PCB에 저장하고, 새로운 프로세스의 상태를 레지스터에 저장하는 것을 말함.

인터럽트의 종류 :
I/O Request : 입출력 요청
Time Slice Expired : CPU 사용시간 만료
Fork Child : 자식 프로세스 생성
Wait for interrupt : 인터럽트 처리 대기

컨텍스트 스위칭 시 CPU는 아무런 작업을 하지 못한다. 따라서 잦은 컨텍스트 스위칭은 성능 저하를 일으킴.

#### CPU 스케줄링

스케줄러란 CPU와 같은 자원을 우선순위에 기반하여 프로세스에 할당하는 방법을 말한다. 그 Queue에는 세 가지가 있다.

- Job Queue : 현재 시스템 안에서 돌고 있는 프로세스의 집합
- Ready Queue : 메모리 안에서 CPU의 할당을 기다리는 프로세스의 집합
- Device Queue : 장치 입출력을 기다리고 있는 프로세스의 집합

스케줄러의 종류 세 가지 :

- 장기 스케줄러 (잡 스케줄러) : 프로세스가 한꺼번에 많이 올라올 시, 메모리와 디스크 사이에서 메모리에, Ready Queue에 어떤 걸 집어넣을지 결정
- 단기 스케줄러 (CPU 스케줄러) : CPU와 메모리 사이에서 Ready Queue에 있는 프로세스 중 어떤 것을 CPU 할당을 받게 할지 스케줄링
- 중기 스케줄러 (Swapper) : 여유공간 부족 시 공간을 만들기 위해 메모리에서 쫓아내어 디스크로 옮김, 동시에 메모리가 많이 올라가는 것을 조절

CPU 스케줄링 방법 :
스케줄링 대상은 Ready Queue에 있는 프로세스 대상이다.

- FCFS (First Come First Served) : 먼저 온 녀석이 먼저 스케줄링을 받음. 중간에 반환하지 않는 비선점형이며, 시간이 긴 프로세스가 먼저 오면 효율성이 떨어짐
- SJF (Short Job First) : 늦게 오더라도 수행시간이 짧은 프로세스에 먼저 할당. 이렇게 되면 수행시간이 긴 프로세스는 영원히 할당받지 못할 수도 있음(Starvation). 수행시간(CPU Burst Time)은 알지는 못하고 예측만 가능하며, t가 실제시간, r이 예상 시간일때 *r**n*+1=*α**t**n*+(1−*α*)*r**n* (*α*값은 가중치)
- SRT (Short Remaining Time) : 현재 프로세스의 수행시간이 끝나는 시간보다 나중에 오는 프로세스의 수행시간 완료 시간이 더 짧다면, 그 즉시 그 프로세스에게 CPU를 할당. 선점형 스케줄링. Starvation과 CPU 수행 시간을 측정할 수 없다는 문제가 있음
- 우선순위 : 정수로 표현된 우선순위가 더 높은 프로세스에게 할당한다. 선점형 방식과 비선점형 방식으로 나눌 수 있는데, 선점형 방식은 우선순위가 높은 프로세스가 도달하면 그 즉시 그 프로세스에게 CPU를 할당. 비선점형 방식은 Ready Queue의 맨 앞에 그 프로세스를 등록. Starvation과 CPU를 사용못하는 프로세스를 CPU가 무한 대기하는 상태가 있을 수 있음. 오래 기다렸을 경우 우선순위를 높이는 Aging을 통해 해결 가능.
- Round Robin : 현대적인 CPU 스케줄링으로, 각 프로세스는 동일한 CPU 할당 시간을 갖게 됨. 할당시간 만료시 ready queue 맨 뒤에 가서 줄섬. CPU의 사용시간이 제각각일 때 효율적. 반응 속도가 빨라지며, 공정한 스케줄링. 주의할 점은 할당하는 시간(time quantum)이 너무 길다면 FCFS와 다를게 없음. 너무 작다면 잦은 컨텍스트 스위칭이 발생.

#### 동기, 비동기, 블로킹, 넌블로킹 차이

동기는 어떤 일에 대한 요청과 응답(혹은 입출력)이 **동시에** 이루어져야 하는 것
비동기는 어떤 일에 대한 요청과 응답이 동시에 이루어질 필요 없이 **따로** 이루어지는 것.
블로킹은 어떤 요청에 대한 응답이 올 때까지 대기 하는 것. 즉 동기를 위해서는 블로킹 되어야 함
넌블로킹은 어떤 요청에 대해서 응답을 대기하지 않고 계속 루틴을 수행하는 것. 비동기를 위해서는 넌블로킹 되어야 하지만, 넌블로킹이 비동기는 아니다(포함관계라고 생각하면 될 듯). 예를 들어 넌블로킹이면서, 요청에 대한 응답을 계속해서 요구하는 폴링 방식의 경우, 비동기라 보기는 힘들다. 이벤트 핸들러나 인터럽트를 통해 응답을 받는 것이 비동기 모델.

#### 메모리

단편화 :
단편화란 메모리 상에서 적재되고, 해제되는 과정에서 발생하는 메모리 사이의 사용하지 못할 정도로 작은 빈 공간이다. 크게 외부 단편화와 내부 단편화로 나뉜다. 외부 단편화는 프로세스와 프로세스 사이에 발생하는 빈 공간이고, 내부 단편화는 프로세스 안에서 발생하는 빈 공간이다. 외부 단편화는 메모리를 다시 재정렬하는 압축을 통해 해결할 수 있지만, 효율이 좋지 않다.

First Fit : 메모리를 할당할 때, 가장 먼저 발견한 곳에 집어넣음
Best Fit : 메모리를 할당할 때, 사용 가능한 공간 중 가장 작은 곳에 집어넣음(정렬 필요)
Worst Fit : 메모리를 할당할 때, 사용 가능한 공간 중 가장 큰 곳에 집어넣음(정렬 필요)
공간 효율성 : Best Fit > First Fit > Worst Fit
시간 효율성 : First Fit > Best Fit = Worst Fit

가상 메모리 :
가상 메모리는 기존의 물리 메모리를 물리 메모리와 논리 메모리로 나눔으로써 더욱 효과적으로 쓰기 위한 개념이다. 논리 메모리 테이블은 물리 메모리와 보조기억장치 메모리와 매핑되어 있으며, 프로세스는 가상메모리를 물리 메모리처럼 인식하고 사용하게 된다. 이전에는 가상 메모리는 보조기억장치를 주기억장치처럼 쓰게 하는 것으로 알고 있었는데, 이번에 다시 정리하게 되었다.

페이징 :
외부 단편화의 압축 작업을 해소하기 위한 방법론으로, 물리 메모리는 Frame, 논리 메모리는 Page라는 고정 크기의 블록으로 나눈다. 프로세스를 페이지 단위로 나눈 뒤에, 사용하지 않는 영역을 보조기억장치에 적재한다. 이를 페이징 되었다고 하는데, 만약 이 페이징 된 영역에 접근해야 하면 페이징 폴트를 발생시킨 후 메모리에 적재시킨다(요구 페이징). 페이징된 정보는 페이징테이블에 저장된다. 단점으로는 내부 단편화가 발생할 수 있다.

세그멘테이션 :
메모리를 페이지와는 다르게 가변 크기의 세그멘테이션으로 나눈다(물리 메모리 블럭 크기와 다르다). 나누는 시점은 메모리를 사용하게 되는 시점이다. 각 세그멘테이션은 스택, 데이터, 힙, 코드 영역 등으로 나뉘게 된다. 나뉜 세그멘테이션은 시작 주소값과 길이 값이 세그멘테이션 테이블에 저장된다. 자주 사용하면 외부 단편화가 발생할 수 있다.

보통 페이징과 세그멘테이션 둘 다 사용한다고 한다.

가상메모리의 요구 페이징 과정에서 만일 물리 메모리가 모두 사용중일 경우, 페이징 교체가 이루어져야 한다.
교체 흐름 :

1. 디스크에서 필요한 페이지의 위치를 찾는다.
2. 페이지 교체 알고리즘을 통해 희생될 페이지를 찾는다.
3. 찾은 페이지를 비운 후 새 프레임을 덮어쓰고, 테이블을 수정한다.
4. 프로세스를 재시작한다(?).

페이지 교체 알고리즘 종류

- FIFO (First In First Out) : 말 그대로 먼저 들어온 페이지를 먼저 내보낸다. 간단한 알고리즘이지만, 페이지의 중요도를 따지지 않기 때문에 초기 변수가 담긴 페이지를 내려버리는 등 여러 문제를 초래할 수 있다.
- 최적 페이지 교체 (Optimal Page Replacement) : 앞으로 가장 사용되지 않을 페이지를 계산하여 교체한다. 다만 모든 프로세스의 계획을 파악하기가 쉽지 않기 때문에, 어떤 페이지를 교체해야 하는가의 알고리즘을 구현할 때 어려움이 있다.
- LRU (Last Recently Used) : 가장 나중에 사용된 페이지를 교체한다. FIFO보단 낫고 OPT보단 못하다.
- LFU (Least Frequently Used) : 가장 덜 사용된 페이지를 교체한다. 활발한 페이지는 사용이 많이 되었을거라는 가정하에 만든 알고리즘. 초기에 많이 사용되었다가 지금은 사용되지 않는 페이지의 경우 교체가 이루어지지 않는다는 문제가 있다.
- MFU (Most Frequently Used) : 가장 많이 사용된 페이지를 교체한다. 가장 적게 사용된 페이지가 최근에 올라오고 계속 사용될 것이라는 가정. 잘 쓰이지 않는다.